//yt_category_manager-->categoryvideos
//categorywatchtimes

how to align react to backened port for request
chart.js
axios Axios is a promise-based HTTP client for making requests to APIs. It is commonly used in React to fetch data from the backend because of its simpler syntax and automatic JSON parsing.
-----------------------------
video id out of url
How the getVideoId Function Works
The getVideoId function uses the URL class to parse the YouTube Shorts URL and extract the video ID. Here's a step-by-step breakdown:

    Create a URL object: const urlObject = new URL(url);
        This creates a new URL object from the provided URL string.
    Extract the pathname: const pathname = urlObject.pathname;
        The pathname property returns the path part of the URL, excluding the protocol, hostname, and query string.
    Split the pathname: const videoId = pathname.split('/').pop();
        The split('/') method splits the pathname into an array of substrings separated by forward slashes (/).
        The pop() method returns the last element of the array, which is the video ID.

Example Walkthrough
For the URL https://www.youtube.com/shorts/41L6QnmRsvk, here's how the function works:

    urlObject is created with the URL string.
    pathname is extracted: /shorts/41L6QnmRsvk.
    pathname is split: ['', 'shorts', '41L6QnmRsvk'].
    pop() returns the last element: 41L6QnmRsvk, which is the video ID.

The function returns the extracted video ID, which can then be used for further processing.



6. i was not adding background script for shorts 

7. how to get the weekly data by subtracting from current date
 const today=new Date();
  const currentDay=today.getDay();
  const diffOfDays=currentDay===0?6:currentDay-1;
   
  const monday=new Date(today);
  monday.setDate(today.getDate()-6)
  monday.setHours(0,0,0,0)
  today.setHours(23,59,59,999)
  const weeklyData = await CategoryWatchTime.find({
    date: {
      $gte: monday,
      $lte: today
    }
  });

  8. Getting the correct port of react for dashboard
  const POSSIBLE_PORTS = [5173, 3001, 5174, 5175, 3000]; 

async function getReactPort() {
    for (const port of POSSIBLE_PORTS) {
        try {
            // Fetch `manifest.json`, which React/Vite always serves
            const response = await fetch(`http://localhost:${port}/manifest.json`, { mode: "no-cors" });
            console.log(`React dev server found on port: ${port}`);
            return port; // Return the first successful port
        } catch (error) {
            continue; // Try next port if fetch fails
        }
    }
    return null; // No React frontend found
}
why manifest.json here
    React and Vite development servers typically serve the manifest.json file at the root of the application.
    By attempting to fetch manifest.json from a given port, the function can determine whether a React development server is running on that port.
    If the fetch is successful, it indicates that a React development server is running on that port, and the function can return the port number.

    9.

   await HourWatch.findOneAndUpdate(
      { date: dateKey, hour },
      { $inc: { duration: durationPerMinute } },
      { upsert: true, new: true }
    );

        HourWatch.findOneAndUpdate(): This method finds a single document matching the specified filter (in this case, { date: dateKey, hour }) and updates it with the specified update operations (in this case, { $inc: { duration: durationPerMinute } }).
    { date: dateKey, hour }: This is the filter used to find the document to update. It's looking for a document where the date field matches dateKey and the hour field matches the hour variable.
    { $inc: { duration: durationPerMinute } }: This is the update operation. $inc is a MongoDB operator that increments the value of a field by a specified amount. In this case, it's incrementing the duration field by durationPerMinute.
    { upsert: true, new: true }: These are options for the findOneAndUpdate method.
        upsert: true means that if no document matches the filter, a new document will be inserted with the update operations applied.
        new: true means that the method will return the updated or inserted document.

So, overall, this code is incrementing the duration field of a document in the HourWatch collection by durationPerMinute, or creating a new document if one doesn't exist, and then returning the updated or inserted document.
Here's an example:
Let's say dateKey is '2022-01-01', hour is 12, and durationPerMinute is 10. If there's already a document in the HourWatch collection with date: '2022-01-01' and hour: 12, its duration field will be incremented by 10. If there isn't a matching document, a new one will be created with date: '2022-01-01', hour: 12, and duration:

 10. for setData in case of arr we can pass newArray directly setData[newArray] but for updated array we have to pass [...arr,8]

 11.
import { Pie } from "react-chartjs-2";
import { Chart as ChartJS, Tooltip, Legend, ArcElement } from "chart.js"; 
 Pie is a component from the react-chartjs-2 library, which is used to render a pie chart.
ChartJS, Tooltip, Legend, and ArcElement are components from the chart.js library, which is used to customize the chart.

ChartJS.register(Tooltip, Legend, ArcElement);

    This line registers the Tooltip, Legend, and ArcElement components with the ChartJS library, making them available for use in the chart.
12.
const [totalTime, setTotalTime] = useState(0);
const [chartData, setChartData] = useState({
  labels: [],
  datasets: [
    {
      data: [],
      backgroundColor: [],
    },
  ],
});

    totalTime is a state variable that stores the total time of all categories.
    chartData is a state variable that stores the data for the pie chart, including labels, data points, and background colors.
    useState is used to initialize these state variables with default values.

13.

   const options = {
  plugins: {
    legend: {
      position: "bottom",
      labels: {
        color: "#374151", // Tailwind's gray-700
        font: {
          size: 14,
          family: "Inter, sans-serif",
        },
        padding: 20,
      },
    },
    tooltip: {
      callbacks: {
        label: (tooltipItem) => {
          const value = tooltipItem.dataset.data[tooltipItem.dataIndex];
          const time = formatTime(value);
          return `${tooltipItem.label}: ${time}`;
        },
      },
    },
  },
};
-------------------
14.
function formatTime(seconds) {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secondsRemaining = Math.round(seconds % 60);

  let timeString = "";
  if (hours > 0) timeString += `${hours}h `;
  if (minutes > 0 || timeString !== "") timeString += `${minutes}m `;
  if (secondsRemaining > 0 && timeString === "") timeString += `${secondsRemaining}s`;

  return timeString.trim();
}

    This function takes a time value in seconds and formats it into a string in the format "Xh Ym Zs".


useEffect(() => {
  const labels = categories.map((cat) => cat.category);
  const data = categories.map((cat) => cat.watchTime);
  const total = data.reduce((sum, val) => sum + val, 0);

  setChartData({
    labels,
    datasets: [
      {
        data,
        backgroundColor: [
          "#FF6384",
          "#36A2EB",
          "#FFCE56",
          "#4CAF50",
          "#FF4500",
          "#9C27B0",
          "#3F51B5",
          "#FF0000",
        ],
      },
    ],
  });

  setTotalTime(total);
}, [categories]);

----------------------
15.
Backend:

npm install socket.io

Frontend (React):

npm install socket.io-client

backend-->  io.emit("dailyUpdated", {...});

 React Frontend Setup

import { useEffect } from 'react';
import { io } from 'socket.io-client';

const socket = io('http://localhost:3000'); 

error ❗️Fix Required: socket.on inside fetchData()

You're registering the socket listener inside the fetchData() function, which runs once, but socket listeners can pile up if not handled carefully.

 fetchData();

    // ✅ Listen to socket updates
    socket.on("watchTimeDataUpdate", (data) => {
        console.log("Socket update received", data);
        setWatchTime(data);

            return () => {
        socket.off("watchTimeDataUpdate");
    };
}, []);

16.
Since you're using Socket.IO, you also need to configure CORS for Socket.IO specifically in your Node.js backend.

You have to specify CORS twice because you're dealing with two different things in your backend:
🔹 1. app.use(cors(...)) → For normal HTTP requests (like fetch)

This applies to Express. It tells Express to allow requests from your frontend (like your fetch("http://localhost:3000/watchtime") call).
🔸 2. cors option in new Server() → For WebSocket (Socket.IO) connections

This applies to Socket.IO. Even though Socket.IO is running over the same server, it manages WebSocket and polling requests separately from Express, and needs its own CORS configuration.


two:-  cors one for http request and other for socket.io
app.use('/uploads', express.static(path.join(__dirname, 'uploads')));


17.
    If you're using import statements to import modules, use export statements to export values.
    If you're using require statements to import modules, use module.exports to export values.
18.

iterating over object of keys

catergoryUsage:{
        "Entertainment & Media":Number,
        "Sports & Gaming":Number,
        "News & Education":Number,
        "Tech & How-To":Number,
        "Music":Number
    }

Object.keys(categoryUsage).map(category => {
  console.log(category, categoryUsage[category]);
});

find()
const categoryKey = Object.keys(categoryUsage).find(key => key === "Entertainment & Media");
console.log(categoryKey, categoryUsage[categoryKey]);wrong Object is a keyWord
    
    
    const existingLimitCategory = Object.keys(limitRecord.catergoryUsage).find(c => c === category);

    19.
    const watchHistory = mongoose.model("WatchHistory", watchHistorySchema);

The correct syntax for creating a model in Mongoose is mongoose.model("ModelName", schema). The model name should be the first argument, and the schema should be the second argument.

20.
content.js, because only content scripts can access and modify the actual YouTube page DOM. 
timelimit exceed popup

21.
    manifest_version: Specifies the version of the manifest file format. Currently, it's version 3.
    name: The name of the extension.
    version: The version number of the extension.
    description: A short description of the extension.
    icons: An object containing icons for the extension in different sizes (e.g., 16x16, 48x48, 128x128).
    background: Specifies the script that runs in the background, allowing the extension to interact with web pages and perform tasks.
        service_worker: The script that runs in the background.
    content_scripts: An array of scripts that are injected into web pages.
        matches: Specifies the URLs that the script should be injected into.
        js: An array of JavaScript files to inject.
    permissions: An array of permissions that the extension requires, such as access to tabs, storage, or specific websites.
    action: Specifies the action (e.g., popup, icon) that the extension performs when the user interacts with it.
        default_popup: The HTML file that is displayed when the user clicks the extension's icon.
        default_icon: The icon that is displayed in the toolbar.
    host_permissions: Specifies the websites that the extension has access to.

22.
    <ShortsLobby shorts={watchHistory.filter(video => video.isShorts)} />
23.
    {array.slice().reverse().map((item, index) => (
  // render item here
))}

24.
: Sorting numbers in ascending order
JavaScript

const numbers = [4, 2, 7, 1, 3];
const sortedNumbers = numbers.sort((a, b) => a - b);
console.log(sortedNumbers); // [1, 2, 3, 4, 7]

Example 2: Sorting numbers in descending order
JavaScript

const numbers = [4, 2, 7, 1, 3];
const sortedNumbers = numbers.sort((a, b) => b - a);
console.log(sortedNumbers); // [7, 4, 3, 2, 1]

Example 3: Sorting strings in alphabetical order
JavaScript

const strings = ['hello', 'world', 'abc', 'xyz'];
const sortedStrings = strings.sort((a, b) => a.localeCompare(b));
console.log(sortedStrings); // ['abc', 'hello', 'world', 'xyz']

Example 4: Sorting objects by a property
JavaScript

const objects = [
  { name: 'John', age: 30 },
  { name: 'Jane', age: 25 },
  { name: 'Bob', age: 40 }
];
const sortedObjects = objects.sort((a, b) => a.age - b.age);
console.log(sortedObjects);
// [
//   { name: 'Jane', age: 25 },
//   { name: 'John', age: 30 },
//   { name: 'Bob', age: 40 }
// ]
25.
   PS D:\React\EXTENSIONS\TRACKER - Copy\backened> netstat -ano | findstr 3000 
  TCP    0.0.0.0:3000           0.0.0.0:0              LISTENING       20632
  TCP    127.0.0.1:3000         127.0.0.1:65375        TIME_WAIT       0
  TCP    127.0.0.1:3000         127.0.0.1:65376        TIME_WAIT       0
  TCP    [::]:3000              [::]:0                 LISTENING       20632
 PS D:\React\EXTENSIONS\TRACKER - Copy\backened> taskkill /F /PID 20632
26.
 difference bt .find and .filter in js
In JavaScript, .find() and .filter() are both array methods used for searching through arrays, but they serve different purposes and return different results.
.find()

    Returns the first matching element that satisfies the provided condition.
    If no element is found, it returns undefined.

Example:
Code

const numbers = [1, 2, 3, 4, 5];
const foundNumber = numbers.find(num => num > 3);
console.log(foundNumber); // Output: 4

.filter()

    Returns a new array containing all elements that satisfy the provided condition.
    If no elements are found, it returns an empty array [].

Example:
Code

const numbers = [1, 2, 3, 4, 5];
const filteredNumbers = numbers.filter(num => num > 3);
console.log(filteredNumbers); // Output: [4, 5]

 In summary:

    Use .find() when you need to find a single element that matches a condition.
    Use .filter() when you need to find multiple elements that match a condition.